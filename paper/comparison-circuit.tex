As explained in \cite{TLWRK20}, in order to evaluate the comparison function homomorphically one must start by decomposing the numbers $x$ and $y$ to compare into their vector of digits $\vx$ and $\vy\in\S^k = \F_{p^{d'}}^k$. Then the vectors of digits are encrypted in an SIMD fashion and the comparison is performed by first evaluating the comparison function for each digit in parallel using Lemma \ref{lem:interpolation} and then the lexicographical order with Eq. (\ref{eq:general_lex_order}).

The second step relies essentially on the computations of the $\LT_{\S}$ and $\EQ_\S$ functions which are done in the first step and cannot really be optimized in its own. As explained in Section \ref{sec:background}, $\EQ_{\S}$ can be simply evaluated using the \texttt{IsNonZero} function whose computation is also quite simple.
Unfortunately, the comparison function is not as simple and we have to rely on Lagrange interpolation (Lemma \ref{lem:interpolation}) to compute it. Yet, there are two different ways to evaluate it: either interpolate $\LT_\S$ as a bivariate function over $\S^2$  -- i.e. compute $\LT_\S(x,y)$ -- as done in \cite{TLWRK20}, or transform it as a simple univariate function in $z=x-y$ -- i.e. compute $\LT_\S(x-y,0)$ -- as done in \cite{AINA:NGEG17}. However both \cite{AINA:NGEG17} and \cite{TLWRK20} have evaluated $\LT_\S$ without exploiting the natural structure it offers. In this Section we study the structure of this function in both the bivariate and univariate cases and we show how to exploit it in order to speed-up their evaluation.

Theoretically $d'$ just has to divide $d$ the order of $p$ modulo the cyclotomic index $m$. Note that taking a large $d'$ allows to pack larger digits in each slots and thus increase the throughput of the procedure. However, since the digits are larger, the polynomial resulting from Lagrange interpolation will have degree $p^{d'}-1$ in each variable with $\mathcal{O}(p^{2d'})$ and $\mathcal{O}(p^{d'})$ monomials for the bivariate and univariate case respectively. For a large $d'$, the performance of the procedure will be heavilly degraded. On the other hand, taking a small $d'$, for instance $d'=1$, will allow to perform the digits comparison more efficiently but requires more SIMD slots which will reduce the throughput of the procedure. Nonetheless, the authors of \cite{TLWRK20} proposed a compromise by exploiting the $\F_p$-vector space structure of $\F_{p^{d'}}$.

Their method consists in decomposing each digit $\alpha = \sum_{i=0}^{d'-1}\alpha_i t^i\in\F_{p^{d'}}$ into the vector of its $\F_p$ components $\bm{\alpha} = (\alpha_0,\ldots,\alpha_{d'-1})\in\F_p^{d'}$ by evaluating linear maps. Then, one can compare each digits using $\LT_\S$ for $\S=\F_p$ and the lexicographical order on the vectors of $\F_p$-components. Finally one needs to use the lexicographical order a second time over the vector of digits to get the final result. Thus by selecting the value $d'$ appropriately, this trade-off allows them to find a trade-off on the throughput while keeping good performance.  

In this work we will follow their blueprint and thus we will only study the function $\LT_\S$ for $\S=\F_p$.

\subsection{Bivariate interpolation of $\LT_\S$.}
    In contrast to equality, this function depends on the choice of $\S$. Nevertheless, we can fix a certain $\S$ as the default complete set of representatives of $\F_{p}$  and denote $\LT_\S(x,y)$ as $\LT_{\F_p}(x,y)$. Hence from now on we identify the set $\S$ to the interval $[0,p-1]$, where $p\geq 2$ is a prime number. The less-than function can be interpolated using Lemma~\ref{lem:interpolation} and the following truth table:
  \begin{align*}
    \begin{array}{c|ccccc}
      < & 0~ & 1~ & 2~ & \cdots & p-1 \\
      \hline
      0 & 0 & 1 & 1 & \cdots & 1 \\
      1 & 0 & 0 & 1 & \cdots & 1 \\
      2 & 0 & 0 & 0 & \cdots & 1 \\
      \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
      p-1 & 0 & 0 & 0 & \cdots & 0 \\
    \end{array}
  \end{align*}
  In particular we can write:
  \begin{align}\label{eq:less_than_function}
    \LT_\S(x,y) &= \sum_{i = 0}^{p-2} \EQ_\S(x,i)\sum_{j = i+1}^{p-1}\EQ_\S(y,j) \nonumber\\
                &= \sum_{i=0}^{p-2} (1-\princhar(x - i)) \sum_{j=i+1}^{p-1} (1-\princhar (y - j)) \nonumber\\
                &= \sum_{i=0}^{p-2} (1-(x - i)^{p-1}) \sum_{j=i+1}^{p-1} (1-(y - j)^{p-1}).
  \end{align}

  At first sight this polyomial seems to have a total degree at most $2p-2$. It appears this is not the case:

  \begin{theorem} \label{lem:less_than_total_degree}
    Let $p>2 $ be a prime number and $\S = [0,p-1]$, then $\LT_\S$ is a polynomial of the following form over $\F_p$:
    \begin{align*}
      \LT_\S(x,y) = y^{p-1} - \frac{p-1}{2} (xy)^{\frac{p-1}{2}} + \sum_{\substack{i,j>0 \\ i+j \le p}} a_{ij} x^i y^j 
    \end{align*}
    where $a_{ij} = \sum_{a=0}^{p-2} \sum_{b=a+1}^{p-1} a^{p-1-i} b^{p-1-j} \in \F_p$. In particular, it has total degree at most $p$.
  \end{theorem}
  
  To prove this statement we need the following lemma.

  \begin{lemma}\label{lem:difference_to_p-1}
    For all $a,b\in\F_p^2$ we have:
    \[
      (a - b)^{p-1} = \sum_{i=0}^{p-1} a^i b^{p-1-i} \mod p.
    \]
  \end{lemma}
  \begin{proof}
    Using the binomial theorem we obtain
    \[
      (a - b)^{p-1} = \sum_{i=0}^{p-1} \binom{p-1}{i} a^i (-b)^{p-1-i}.
    \]
    Computing the binomial coefficient modulo $p$
    \begin{align*}
      \binom{p-1}{i} & = \frac{(p-1)!}{i! (p-1-i)!} \\
      & = \frac{(p-1)(p-2)\dots(i+1)}{1 \cdot 2 \dots (p-(1+i))} = (-1)^{p-1-i} \mod p\,,
    \end{align*}
    we prove the lemma.
  \end{proof}

  \begin{lemma}\label{lem:sum_poly}
    Let $P(x)$ be a polynomial of degree $d$ less than $p-1$.
    For any prime number $p > 2$, it holds
    \[
      \sum_{a=0}^{p-1} P(a) = 0 \mod p.
    \]
  \end{lemma}
  \begin{proof}
    It is enough to prove that $\sum_{a=0}^{p-1} a^n = 0 \mod p$ for any $0 \leq n < p-1$. For $n = 0$, the sum is equal to $p$ which is congruent to $0$ modulo p. Now let us consider the case $n\geq 1$ and let $g$ be a primitive element of $\F_p$.
    Since $p > 2$, we have $g \ne 1$.
    Thus, we can rewrite the above sum as follows.
    \begin{align*}
      \sum_{a=0}^{p-1} a^{n} = \sum_{a=1}^{p-1} a^{n} = \sum_{i=1}^{p-1} g^{in} = \frac{g^{pn} - g^n}{g^n - 1}.
    \end{align*}
    Since $g^{pn} \equiv g^n \mod p$, the sum turns into zero modulo $p$.
  \end{proof}

  Now we can start the proof of Theorem \ref{lem:less_than_total_degree}.
  
  \begin{proof}[Theorem \ref{lem:less_than_total_degree}]
    Assume that all computations are done modulo $p$.
    Using Lemma~\ref{lem:difference_to_p-1}, we obtain:
    \begin{align*}
      \LT_\S(x,y) &=  \sum_{a = 0}^{p-2} \left(1-\sum_{i=0}^{p-1} x^i a^{p-1-i}\right) \sum_{b=a+1}^{p-1} \left(1-\sum_{j=0}^{p-1} y^j b^{p-1-j}\right).
    \end{align*}
    Let us expand this expression distributively.
    \begin{align*}
      \sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} 1 - \sum_{i=0}^{p-1} x^i a^{p-1-i} - \sum_{i=0}^{p-1} y^i b^{p-1-i} + \sum_{i=0}^{p-1} \sum_{j=0}^{p-1} x^i y^j a^{p-1-i} b^{p-1-j}.
    \end{align*}
    Let us separately compute polynomial coefficients.
    The constant term is equal to
    \begin{align*}
      \sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} 1 - a^{p-1} - b^{p-1} + a^{p-1} b^{p-1} = \sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} 1 - a^{p-1} - 1 + a^{p-1} = 0 
    \end{align*}
    The coefficients by $x^i$ with $i > 0$ can be computed as follows
    \begin{align*}
      \sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} \left(-a^{p-1-i}\right) + a^{p-1-i} = 0.
    \end{align*}
    Next, we compute the coefficients by $y^i$ with $i > 0$.
    \begin{align*}
      -\sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} b^{p-1-i} - a^{p-1} b^{p-1-i} &= -\sum_{b=1}^{p-1} b^{p-1-i} - \sum_{a = 1}^{p-2} \sum_{b=a+1}^{p-1} b^{p-1-i} - b^{p-1-i} \\
      &= -\sum_{b=1}^{p-1} b^{p-1-i}.
    \end{align*}
    If $i = p-1$, this sum is equal to $1$.
    According to Lemma~\ref{lem:sum_poly}, it is $0$ if $i \ne 0 \mod (p-1)$.
    
    To compute coefficients by $x^i y^j$ with $i, j > 0$, we will use Faulhaber's formula below
    \begin{align*}
      \sum_{k=1}^n k^e = \frac{1}{e+1} \sum_{i=1}^{e+1} (-1)^{\delta_{ie}} \binom{e+1}{i} B_{e+1-i} \cdot n^i\,,
    \end{align*}
    where $\delta_{ie}$ is the Kronecker delta and $B_{i}$ is the $i$th Bernoulli number.
    This implies that there exist a polynomial $P(x) \in \F_p[X]$ of degree $e+1$ such that
    \begin{align}\label{eq:faulhaber}
      \sum_{k=1}^n k^e = P(n).
    \end{align}
    Note that $P(0) = 0$.
    The coefficient by $x^i y^j$ for some positive $i$ and $j$ is equal to
    \begin{align*}
      \sum_{a = 0}^{p-2} \sum_{b=a+1}^{p-1} a^{p-1-i} b^{p-1-j} = \sum_{b = 1}^{p-1} b^{p-1-j} \sum_{a=0}^{b-1} a^{p-1-i}.
    \end{align*}
    According to~(\ref{eq:faulhaber}), it follows that there exist a polynomial $P(x)$ of degree $p-i$ such that $\sum_{a=0}^{b-1} a^{p-1-i} = P(b)$.
    Since $Q(x) = x^{p-1-j} P(x)$ has degree $2p-1-i-j$, Lemma~\ref{lem:sum_poly} implies that if $i+j > p$, then
    \begin{align*}
      \sum_{b = 1}^{p-1} b^{p-1-j} \sum_{a=0}^{b-1} a^{p-1-i} = \sum_{b=1}^{p-1} Q(b) = 0.
    \end{align*}
    Thus, the total degree of $\LT_\S$ is at most $p$.

    In addition, we consider the case when $i = j$.
    Let us consider the following sum
    \begin{align*}
      \sum_{a=0}^{p-1} a^{p-1-i} \sum_{b=0}^{p-1} b^{p-1-i} = 0.
    \end{align*}
    We can rewrite it as follows
    \begin{align*}
      \sum_{a=0}^{p-1} a^{p-1-i} \sum_{b=0}^{p-1} b^{p-1-i} = 2\sum_{a=0}^{p-2} a^{p-1-i} \sum_{b=a+1}^{p-1} b^{p-1-i} + \sum_{a=0}^{p-1} a^{2(p-1-i)}.
    \end{align*}
    If $i \ne (p-1)/2$, then the last sum is zero.
    Thus, the coefficient by $x^i y^i$ is equal to $\sum_{a=0}^{p-2} a^{p-1-i} \sum_{b=a+1}^{p-1} b^{p-1-i} = 0$.
    If $i = (p-1)/2$, then following the above argument, this coefficient is equal to $-(p-1)/2$.
  \end{proof}

  Now that we know a little bit better what $\LT_\S$ looks like we are gonna enumerate some obvious facts which worth being stated:
  \begin{itemize}
  \item $\LT_\S(x,0) = 0$ thus $y$ divides $\LT_\S(x,y)$.
  \item $\LT_\S(x,x) = \LT_\S(y,y) = 0$ thus $(x-y)$ divides $\LT_\S(x,y)$.
  \item $\LT_\S(p-1,y) = 0$ thus $x+1$ divides $\LT_\S(x,y)$.
  \end{itemize}

  Therefore there exists a bivariate polynomial $f$ of total degree $p-3$ over $\F_p$ such that:
  \begin{equation}
    \label{eq:decompLT}
    \LT_\S(x,y) = y(x-y)(x+1)f(x,y).
  \end{equation}

  
  
\subsection{Univariate interpolation of $\LT_\S$}
  Another way to compare $x$ and $y$ from $\S$ is to compute the difference $x-y$ and find its sign.
  To compute the sign function (or $\LT_\S(x-y,0)$) using finite field arithmetic, we need to split finite field elements into two classes:  negative ($\F_p^-$) and non-negative ($\F_p^+$).
  In addition, for any $x, y \in \S$ the following property should hold
  \begin{align*}
    x - y \in 
    \begin{cases}
      \F_p^+ \text{ if } \LT_\S(x,y) = 0, \\
      \F_p^- \text{ if } \LT_\S(x,y) = 1.
    \end{cases}
  \end{align*}   
  Let $\S = [0, (p-1)/2]$ for a prime odd integer $p$.
  Let us split $\F_p$ into $\F_p^+ = [0, (p-1)/2]$ and $\F_p^- = [-(p-1)/2, -1]$.
  Notice that for any $x, y \in \S$, their difference $x - y$ belongs to $\F_p^-$ if and only if $x < y$.
  According to Lemma~\ref{lem:interpolation}, the indicator function of $\F_p^-$ is equal to
  \begin{align*}
    \chi_{\F_p^-}(z) = \sum_{a=-\frac{p-1}{2}}^{-1} 1 - (z - a)^{p-1}.
  \end{align*}
  In other words, this function outputs $1$ if $z$ is negative and $0$ otherwise.
  Combining the above facts, we obtain the following $\LT_\S$ function.
  \begin{align*}
    \LT_\S(x,y) = \sum_{a=-\frac{p-1}{2}}^{-1} 1 - (x - y - a)^{p-1}.
  \end{align*}
  The following lemma describes all the coefficients of $\LT_\S$.
  \begin{lemma}
    For an odd prime $p$ and $\S = [0, (p-1)/2]$, the $\LT_\S$ function is equal to the following polynomial over $\F_p$
    \begin{align}\label{eq:univariate_circuit}
      \LT_\S(x,y) = \frac{p+1}{2} (x-y)^{p-1} + \sum_{i=1, \text{odd}}^{p-2} (x-y)^i \sum_{a=1}^{\frac{p-1}{2}} a^{p-1-i}.
    \end{align}
  \end{lemma}
  \begin{proof}
    Let $z = x-y$.
    Thus we can rewrite $\LT_\S$ as the univariate indicator function $\chi_{\F_p^-}$, namely
    \begin{align*}
      \LT_\S(x,y) = \chi_{\F_p^-}(z) = \sum_{a=-\frac{p-1}{2}}^{-1} 1 - (z - a)^{p-1}.
    \end{align*}
    Thanks to Lemma~\ref{lem:difference_to_p-1}, we can expand $(z-a)^{p-1}$ and obtain
    \begin{align*}
      \sum_{a=-\frac{p-1}{2}}^{-1} 1 - \sum_{i=0}^{p-1} z^i a^{p-1-i}
      = \sum_{i=1}^{p-1} z^i \sum_{a=-\frac{p-1}{2}}^{-1} (-a^{p-1-i}).
    \end{align*}
    If $i$ is even, then the $i$th coefficient is equal to
    \begin{align*}
      -\sum_{a=-\frac{p-1}{2}}^{-1} a^{p-1-i} &= -\sum_{a=1}^{\frac{p-1}{2}} a^{p-1-i} = -\frac{\sum_{a=-\frac{p-1}{2}}^{\frac{p-1}{2}} a^{p-1-i}}{2}.
    \end{align*}
    This coefficient is equal to $0$ for any positive even $i$ not equal to $p-1$ as $\sum_{a=0}^{p-1} a^{p-1-i} = 0$ in this case.
    The $(p-1)$-th coefficient is equal to $-(p-1)/2 = (p+1)/2$.
    If $i$ is odd, then we can rewrite the $i$th coefficient in the following way
    \begin{align*}
      -\sum_{a=-\frac{p-1}{2}}^{-1} a^{p-1-i} &= \sum_{a=1}^{\frac{p-1}{2}} a^{p-1-i},
    \end{align*}
    which finishes the proof.
  \end{proof}
  The above lemma implies that the less-than function can be expressed by a univariate polynomial of degree $p-1$.
  In general, such polynomials are evaluated in $O(p-1)$ steps according to Horner's method.
  However, in homomorphic computation model, multiplication by a scalar coefficient is usually much cheaper then ``non-scalar'' multiplication of expressions containing input variables $x$ and $y$.
  To reduce the number of non-scalar multiplications, we can resort to the Paterson-Stockmeyer algorithm~\cite{SIAM:PS73} that requires $O(\sqrt{2(p-1)}$ such multiplications.
  However, we can improve this complexity by exploiting the fact that the polynomial in~(\ref{eq:univariate_circuit}) has only one coefficient with an even index, the leading one.
  Thus, we can rewrite~(\ref{eq:univariate_circuit}) as follows
  \begin{align*}
    \alpha_{p-1} z^{p-1} + z \sum_{i=0, \text{even}}^{p-3} \alpha_{i+1} z^i =  \alpha_{p-1} z^{p-1} + z g(z^2)
  \end{align*}
  where $z = x - y$, $\alpha_i = \sum_{a=1}^{\frac{p-1}{2}} a^{p-1-i}$ and $g(X)$ is a polynomial of degree $(p-3)/2$.
  To evaluate $g(X)$, the Paterson-Stockmeyer algorithm requires $O(\sqrt{p-3})$ non-scalar multiplications.
  Furthermore, the preprocessing phase of this algorithm computes $z^2, z^4, \dots, z^{2k}$ and $z^{4k}, z^{8k}, \dots, z^{2^r k}$ with $2k(2^r-1) = p-3$.
  We can use these powers to compute the leading term in $m$ steps, namely
  \begin{align*}
    z^2 z^{2k} z^{4k} \cdots z^{2^r k} = z^{2 + 2k(2^r-1)} = z^{2 + p - 3} = z^{p-1}.
  \end{align*}
  Since $r \in O(\log (p/(2k)))$, the asymptotic complexity of evaluating~(\ref{eq:univariate_circuit}) is $O(\sqrt{p-3})$ non-scalar multiplications.
  
  \begin{remark}
    A careful reader can notice that the leading term of~(\ref{eq:univariate_circuit}) is equal to $\chi_p(x-y)$, which is the heaviest part of the equality circuit $\EQ_\S$.
    Thus, we can get $\EQ_\S$ almost for free after evaluating $\LT_\S$, thus saving $O(\log (p-1))$ non-scalar multiplications.
  \end{remark}

\subsubsection{Overall procedure}  
% Theoretically $d'$ just has to divide $d$ the order of $p$ modulo the cyclotomic index $m$. Note that taking $d'$ as large as possible allows to pack larger digits in each slots and thus increase the throughput of the procedure. However, as shown in \ref{eq:nonzero_depth}, the multiplicative depth required to evaluate \texttt{IsNonZero} increases with the degree $d'$ of the considered field. On the other hand, taking a small $d'$, for instance $d'=1$ will allow to perform the digits comparison more efficiently


% \subsection{Lexicographic order}\label{subsec:lexicographic_order}
%   Let $\vx=(x_0,x_1,\ldots,x_{\ell-1})$ and $\vy=(y_0,y_1,\ldots,y_{\ell-1}) \in \F_\fieldcard^\ell$ for the lexicographical order $<$ defined by the choice of $\S$:
%   \begin{align*}
%     \vx < \vy \Leftrightarrow \exists i\in[0,\ell-1] \text{ such that } x_i < y_i \text{ and } \forall j > i ~~ x_j = y_j\,.
%   \end{align*}
%   This order induces a function $\LT_{\F_\fieldcard}(\vx, \vy)$ that returns $1$ if $\vx < \vy$ and $0$ otherwise. 
%   As done in~\cite{TLWRK20}, we can employ $\EQ_{\F_\fieldcard}$ and $\LT_{\F_\fieldcard}$ to compute $\LT_{\F_\fieldcard}(\vx, \vy)$ as follows
%   \begin{align*}
%     \LT_{\F_\fieldcard}(\vx, \vy) = \sum_{i=0}^{\ell-2} \LT_{\F_\fieldcard}(x_{i}, y_{i}) \prod_{j=i+1}^{\ell-1} \EQ_{\F_\fieldcard}(x_{j}, y_{j}) + \LT_{\F_\fieldcard}(x_{\ell-1}, y_{\ell-1}).
%   \end{align*}
%   Notice that the multiplicative depth of this function solely depends on the products of the equality functions.
%   In fact, these products compare subvectors $\vx_i = (x_i, x_{i+1},\dots,x_{\ell-1})$ and $\vy_i = (y_i, y_{i+1},\dots,y_{\ell-1})$ for $i \in [1,\ell-1]$.
%   Thus, we can rewrite $\LT_{\F_\fieldcard}$ as
%   \begin{align}\label{eq:general_lex_order}
%     \LT_{\F_\fieldcard}(\vx, \vy) = \sum_{i=0}^{\ell-2} \LT_{\F_\fieldcard}(x_{i}, y_{i}) \EQ_{\F_\fieldcard}(\vx_{i+1}, \vy_{i+1}) + \LT_{\F_\fieldcard}(x_{\ell-1}, y_{\ell-1})
%   \end{align}
%   with the equality function $\EQ_{\F_\fieldcard}(\vx_{i+1}, \vy_{i+1})$ that returns $1$ if $\vx_{i+1} = \vy_{i+1}$ and $0$ otherwise.
%   As shown in~\todo{cite our work}, this function can be realized by a constant-depth circuit in the following way.
%   \begin{align}\label{eq:rand_eq_circuit}
%     \EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1}) = 1 - \princhar_{\fieldcard^e}\left(\sum_{j=i+1}^{\ell-1} r_j (x_j - y_j)\right)
%   \end{align}
%   where $r_j$ are uniformly random elements from $\F_{\fieldcard^e}$.
%   This circuit is false-biased with error probability $\fieldcard^{-e}$.
%   We can compute all $\EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1})$ using the same number of multiplications as for the single equality using Algorithm~\ref{alg:vector_equalities_circuit}.\todo{What is the complexity?}

\subsection{Min/max function}

  Given the less-than function $\LT_\S$ defined on a set $\S$, one can compute the minimum of two elements $x$ and $y$ in the generic way, namely
  \begin{align*}
    \min_\S(x,y) = x \cdot \LT_\S(x,y) + y \cdot (1 - \LT_\S(x,y)).
  \end{align*}
  Notice that the difference $x - y$ naturally emerges in this expression, thus hinting that the univariate circuit from~\ref{eq:univariate_circuit} might be useful here.
  Indeed, by replacing $x - y$ with an indeterminate $z$ we obtain the univariate polynomial representation of the minimum function 
  \begin{align*}
    \min_\S(x,y) & = y + z \cdot \left(\frac{p+1}{2} z^{p-1} + \sum_{i=1, \text{odd}}^{p-2} z^i \sum_{a=1}^{\frac{p-1}{2}} a^{p-1-i}\right) \\
    & = y + \frac{p+1}{2} z + \sum_{i=1}^{\frac{p-1}{2}} z^{2i} \sum_{a=1}^{\frac{p-1}{2}} a^{p-2i} \\
    & = \frac{p+1}{2} (x+y) + \sum_{i=1}^{\frac{p-1}{2}} z^{2i} \sum_{a=1}^{\frac{p-1}{2}} a^{p-2i} \\
    & = \frac{p+1}{2} (x+y) + g(z^2)
  \end{align*}
  where $g(X)$ is a polynomial of degree $(p-1)/2$. 
  As a result, $\min(x,y)$ can be computed with $O(\sqrt{p-1})$ non-scalar multiplications via the Paterson-Stockmeyer algorithm.

  Following the above reasoning, the maximum function can be computed as follows
  \begin{align*}
    \max_\S(x,y) &= \frac{p+1}{2} (x+y) - \sum_{i=1}^{\frac{p-1}{2}} z^{2i} \sum_{a=1}^{\frac{p-1}{2}} a^{p-2i}.
  \end{align*}
  This yields a simple polynomial for the ReLU function.
  \begin{align*}
    \ReLU_\S(x) = \max_\S(x,0) &= \frac{p+1}{2} x - \sum_{i=1}^{\frac{p-1}{2}} x^{2i} \sum_{a=1}^{\frac{p-1}{2}} a^{p-2i}.
  \end{align*}

\subsection{Lexicographic order}\label{subsec:lexicographic_order}
  Let $\vx=(x_0,x_1,\ldots,x_{\ell-1})$ and $\vy=(y_0,y_1,\ldots,y_{\ell-1}) \in \F_\fieldcard^\ell$ for the lexicographical order $<$ defined by the choice of $\S$:
  \begin{align*}
    \vx < \vy \Leftrightarrow \exists i\in[0,\ell-1] \text{ such that } x_i < y_i \text{ and } \forall j > i ~~ x_j = y_j\,.
  \end{align*}
  This order induces a function $\LT_{\F_\fieldcard}(\vx, \vy)$ that returns $1$ if $\vx < \vy$ and $0$ otherwise. 
  As done in~\cite{TLWRK20}, we can employ $\EQ_{\F_\fieldcard}$ and $\LT_{\F_\fieldcard}$ to compute $\LT_{\F_\fieldcard}(\vx, \vy)$ as follows
  \begin{align*}
    \LT_{\F_\fieldcard}(\vx, \vy) = \sum_{i=0}^{\ell-2} \LT_{\F_\fieldcard}(x_{i}, y_{i}) \prod_{j=i+1}^{\ell-1} \EQ_{\F_\fieldcard}(x_{j}, y_{j}) + \LT_{\F_\fieldcard}(x_{\ell-1}, y_{\ell-1}).
  \end{align*}
  Notice that the multiplicative depth of this function solely depends on the products of the equality functions.
  In fact, these products compare subvectors $\vx_i = (x_i, x_{i+1},\dots,x_{\ell-1})$ and $\vy_i = (y_i, y_{i+1},\dots,y_{\ell-1})$ for $i \in [1,\ell-1]$.
  Thus, we can rewrite $\LT_{\F_\fieldcard}$ as
  \begin{align}\label{eq:general_lex_order}
    \LT_{\F_\fieldcard}(\vx, \vy) = \sum_{i=0}^{\ell-2} \LT_{\F_\fieldcard}(x_{i}, y_{i}) \EQ_{\F_\fieldcard}(\vx_{i+1}, \vy_{i+1}) + \LT_{\F_\fieldcard}(x_{\ell-1}, y_{\ell-1})
  \end{align}
  with the equality function $\EQ_{\F_\fieldcard}(\vx_{i+1}, \vy_{i+1})$ that returns $1$ if $\vx_{i+1} = \vy_{i+1}$ and $0$ otherwise.
  As shown in~\todo{cite our work}, this function can be realized by a constant-depth circuit in the following way.
  \begin{align}\label{eq:rand_eq_circuit}
    \EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1}) = 1 - \princhar_{\fieldcard^e}\left(\sum_{j=i+1}^{\ell-1} r_j (x_j - y_j)\right)
  \end{align}
  where $r_j$ are uniformly random elements from $\F_{\fieldcard^e}$.
  This circuit is false-biased with error probability $\fieldcard^{-e}$.
  We can compute all $\EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1})$ using the same number of multiplications as for the single equality using Algorithm~\ref{alg:vector_equalities_circuit}.\todo{What is the complexity?}

  \begin{algorithm}[t]
    \KwIn{
    $\ct_\vx$ -- a ciphertext encrypting $\vx \in \F^\ell_\fieldcard$,
    $\ct_\vy$ -- a ciphertext encrypting $\vy \in \F^\ell_\fieldcard$.
    }
    \KwOut{$\ct$ -- a ciphertext containing the output of $\EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1})$ in the $i$th SIMD slot}
    $\ct_1 \leftarrow \Shift(\ct_\vx, 1)$ // removes the value $x_0$ and shifts $\vx$ to the left\\
    $\ct_2 \leftarrow \Shift(\ct_\vy, 1)$ // removes the value $y_0$ and shifts $\vy$ to the left\\
    $\ct \leftarrow \Sub(\ct_1, \ct_2)$ // $(x_i - y_i), i \in [1,\ell-1]$\\
    $r_0,r_1,\dots,r_{\ell-1} \leftarrow \udist(\F_{\fieldcard^e})$ //\todo{define uniform distribution}\\ 
    $\pt_r \leftarrow \pt(r_0,r_1,\dots,r_{\ell-1})$\\
    $\ct \leftarrow \ct \cdot \pt_r$ // $r_i(x_i - y_i), i \in [1,\ell-1]$\\
    $k \leftarrow 1$// $\sum_{j=i}^{\ell-1} r_i(x_i - y_i), i \in [1,\ell-1]$\\
    \While{$k < \ell-1$}{
      $\ct_{tmp} \leftarrow \Shift(\ct, k)$\\
      $\ct \leftarrow \ct + \ct_{tmp}$\\
      $k \leftarrow 2k$\\
    }
    $\ct \leftarrow \Power(\ct, \fieldcard^e-1)$ //$\princhar_{\fieldcard^e}\left(\sum_{j=i}^{\ell-1} r_i(x_i - y_i)\right), i \in [1,\ell-1]$ \\
    $\ct \leftarrow 1 - \ct$\\
    \textbf{Return} $\ct$.
    \caption{Homomorphic circuit computing $\EQ_{\F_\fieldcard, e}(\vx_{i+1},\vy_{i+1})$ in parallel.}\label{alg:vector_equalities_circuit}
  \end{algorithm}
  
  Let us go back to the lexicographic order in equation~(\ref{eq:general_lex_order}).
  Assume that we have a ciphertext $\ct_{\LT}$ containing $\LT_{\F_\fieldcard}(x_i, y_i)$ in the $i$th slot (\todo{elaborate on that}) and the output $\ct_{\EQ}$ of Algorithm~\ref{alg:vector_equalities_circuit}.
  We set the $\ell-1$ slot of $\ct_{\EQ}$ to $1$ and multiply it by $\ct_{\LT}$.
  The resulting ciphertext contains all the products $\LT_{\F_\fieldcard}(x_{i}, y_{i}) \EQ_{\F_\fieldcard}(\vx_{i+1}, \vy_{i+1})$ for any $i \in [0,\ell-2]$ and $\LT_{\F_\fieldcard}(x_{\ell-1}, y_{\ell-1})$, which can be summed in the same way as in the while circuit of Algorithm~\ref{alg:vector_equalities_circuit}.
  As a result, we obtain a ciphertext with the output of $\LT_{\F_\fieldcard}(\vx, \vy)$ in the first SIMD slot.

  \subsubsection{Comparing large integers.}
  Since any integer $z$ can be represented in base $\fieldcard$ as $z = \sum_{i=0}^{\ell-1} z_i q^i$, we can encode $z$ into SIMD slots as a vector $(z_0,z_1,\dots,z_{\ell-1}) \in \F_{\fieldcard}^\ell$.
  As shown above, we can compare such vectors using the lexicographic order function in~(\ref{eq:general_lex_order}) and thus compare integers larger than $\fieldcard$.

  \todo{Incorporate the following into the complexity analysis.} 
  We can obtain ciphertexts encrypting $(x,x,\ldots, x)$ and $(y,y,\ldots, y)$ with $2\log_2(q-1)\texttt{Rot}$ and $2\log_2(q-1)\texttt{Add}$. 

  From there we can obtain encryptions of $(x,x-1,\ldots, x-q-2)$ and $(y-1,y-2,\ldots, y-q-1)$ with $2\texttt{Add}$. We can apply $f$ to these vectors in parallel with a depth of $\log (p-1) + \log d$ for a cost of $2(\log (p-1) + wt(p-1) + d - 2) \texttt{Mult}$. This can be minimized by choosing $p = 2^d + 1$ for some $d$.

  With $2$ more $\texttt{Sub}$ we obtain encryptions of $(1-f(x), 1-f(x-1), \ldots, 1-f(x-q-2))$ and $(1-f(y-1), 1-f(y-2), \ldots, 1-f(y-q-1))$. From there we can get an encryption of the different partial sums in $\log_2(q-1)\texttt{Rot}$, $\log_2(q-1)\texttt{Select}$ and $\log_2(q-1)\texttt{Add}$. The algorithm works as follow:

  \begin{center}
    \begin{tikzpicture}[scale=0.8]
      \newcommand\y{-4};
      
      \draw (0,2) -- (16,2);
      \draw (0,0) -- (16,0);    
      \foreach \x in {0,...,8}{
        \draw (2*\x,0) -- (2*\x,2);
      }
      \foreach \x in {0,...,7}{
        \node at (2*\x+1,1) {$x_\x$};
      }

      \draw (0,2+\y) -- (16,2+\y);
      \draw (0,\y) -- (16,\y);    
      \foreach \x in {0,...,8}{
        \draw (2*\x,0+\y) -- (2*\x,2+\y);
      }

      \node at (1,1+\y) {$x_0 + x_1$};
      \node at (3,1+\y) {$x_1 + x_2$};
      \node at (5,1+\y) {$x_2 + x_3$};
      \node at (7,1+\y) {$x_3 + x_4$};
      \node at (9,1+\y) {$x_4 + x_5$};
      \node at (11,1+\y) {$x_5 + x_6$};
      \node at (13,1+\y) {$x_6 + x_7$};
      \node at (15,1+\y) {$x_7$};

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      
      \draw (0,2+2*\y) -- (16,2+2*\y);
      \draw (0,0+2*\y) -- (16,0+2*\y);    
      \foreach \x in {0,...,8}{
        \draw (2*\x,0+2*\y) -- (2*\x,2+2*\y);
      }

      \node at (1,1+2*\y) {$\begin{array}{c}
          x_0 + x_1  \\
          + x_2 + x_3
        \end{array}$};
      \node at (3,1+2*\y) {$\begin{array}{c}
          x_1 + x_2  \\
          + x_3 + x_4
        \end{array}$};
      \node at (5,1+2*\y) {$\begin{array}{c}
          x_2 + x_3  \\
          + x_4 + x_5
        \end{array}$};
      \node at (7,1+2*\y) {$\begin{array}{c}
          x_3 + x_4  \\
          + x_5 + x_6
        \end{array}$};
      \node at (9,1+2*\y) {$\begin{array}{c}
          x_4 + x_5  \\
          +x_6 + x_7
        \end{array}$};
      \node at (11,1+2*\y) {$\begin{array}{c}
          x_5 + x_6  \\
          + x_7
        \end{array}$};
      \node at (13,1+2*\y) {$x_6 + x_7$};
      \node at (15,1+2*\y) {$x_7$};

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      
      \draw (0,2+3*\y) -- (16,2+3*\y);
      \draw (0,0+3*\y) -- (16,0+3*\y);    
      \foreach \x in {0,...,8}{
        \draw (2*\x,0+3*\y) -- (2*\x,2+3*\y);
      }

      \node at (1,1+3*\y) {$\begin{array}{c}
          x_0 + x_1  \\
                              + x_2 + x_3 \\
                              + x_4 + x_5 \\
                              + x_6 + x_7
        \end{array}$};
      \node at (3,1+3*\y) {$\begin{array}{c}
          x_1 + x_2  \\
                              + x_3 + x_4 \\
                              + x_5 + x_6 \\
                              + x_7 \\
        \end{array}$};
      \node at (5,1+3*\y) {$\begin{array}{c}
          x_2 + x_3  \\
                              + x_4 + x_5 \\
                              + x_6 + x_7
        \end{array}$};
      \node at (7,1+3*\y) {$\begin{array}{c}
          x_3 + x_4  \\
                              + x_5 + x_6 \\
                              +x_7
        \end{array}$};
      \node at (9,1+3*\y) {$\begin{array}{c}
          x_4 + x_5  \\
          +x_6 + x_7
        \end{array}$};
      \node at (11,1+3*\y) {$\begin{array}{c}
          x_5 + x_6  \\
          + x_7
        \end{array}$};
      \node at (13,1+3*\y) {$x_6 + x_7$};
      \node at (15,1+3*\y) {$x_7$};

      \foreach \x in {2,...,8}
      \draw[->,thick = 2pt] (2*\x-0.1-1,2) to[bend right] (2*\x-3+0.1,2);

      \foreach \x in {3,...,8}
      \draw[->,thick = 2pt] (2*\x-0.1-1,2+\y) to[bend right] (2*\x-5+0.1,2+\y);

      \foreach \x in {5,...,8}
      \draw[->,thick = 2pt] (2*\x-0.1-1,2+2*\y) to[bend right] (2*\x-9+0.1,2+2*\y);

  \end{tikzpicture}
  \end{center}

  From there we just have to compute the scalar product of the two vectors with $1\texttt{Mult} + \log_2(q-1)\texttt{Rot} + \log_2(q-1)\texttt{Add}$. \newline

  So overall we can compute $<$ over $\mathbb{F}_q$ for $q = p^d$ in:

  \begin{itemize}
  \item $4\log_2 (q-1) \texttt{Rot}$
  \item $(4\log_2 (q-1) + 4) \texttt{Add}$
  \item $(2(\log (p-1) + wt(p-1) + d - 2) + 1) \texttt{Mult}$
  \item $(\log_2 (q-1) + 1) \texttt{Select}$
  \end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
